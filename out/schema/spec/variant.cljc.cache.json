["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Object",["^ "],"~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$schema.spec.variant","~:imports",null,"~:requires",["^ ","~$utils","~$schema.utils","^=","^=","~$spec","~$schema.spec.core","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$option-step",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/ambrose/Projects/schema-local-dev/master/src/cljc/schema/spec/variant.cljc","~:line",12,"~:column",8,"~:end-line",12,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^M",[["~$o","~$params","~$else"]]]]]],"^K",true,"^8","~$schema.spec.variant/option-step","^F","src/cljc/schema/spec/variant.cljc","^J",19,"~:method-params",["^M",[["~$o","^O","^P"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^H",1,"~:variadic?",false,"^G",12,"~:ret-tag",["^7",["~$any","~$function"]],"^I",12,"~:max-fixed-arity",3,"~:fn-var",true,"^L",["^M",["^N",["^M",[["~$o","^O","^P"]]]]]],"~$VariantSpec",["^ ","~:num-fields",4,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$schema.spec.core/CoreSpec","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$schema.spec.variant/VariantSpec","^F","src/cljc/schema/spec/variant.cljc","^J",23,"~:type",true,"^H",12,"~:internal-ctor",true,"^G",41,"~:record",true,"^I",41,"~:tag","^X","~:skip-protocol-flag",["^7",["^12","^13","^14","^15","^16","^17","^19","^1:","^1;","^1<","^1=","^1>","^1?","^1@","^1A"]]],"~$->VariantSpec",["^ ","^D",null,"^E",["^ ","^F","/Users/ambrose/Projects/schema-local-dev/master/src/cljc/schema/spec/variant.cljc","^G",41,"^H",12,"^I",41,"^J",23,"^1D",true,"~:factory","~:positional","^L",["^M",["^N",["^M",[["~$pre","~$options","~$err-f","~$post"]]]]],"~:doc","Positional factory function for schema.spec.variant/VariantSpec."],"^8","~$schema.spec.variant/->VariantSpec","^F","src/cljc/schema/spec/variant.cljc","^J",23,"^R",["^M",[["^1K","^1L","^1M","^1N"]]],"^S",null,"^T",["^M",[null,null]],"^H",1,"^1D",true,"^U",false,"^1I","^1J","^G",41,"^V","^1B","^I",41,"^Y",4,"^Z",true,"^L",["^M",["^N",["^M",[["^1K","^1L","^1M","^1N"]]]]],"^1O","Positional factory function for schema.spec.variant/VariantSpec."],"~$map->VariantSpec",["^ ","^D",null,"^E",["^ ","^F","/Users/ambrose/Projects/schema-local-dev/master/src/cljc/schema/spec/variant.cljc","^G",41,"^H",12,"^I",41,"^J",23,"^1D",true,"^1I","~:map","^L",["^M",["^N",["^M",[["~$G__1023"]]]]],"^1O","Factory function for schema.spec.variant/VariantSpec, taking a map of keywords to field values."],"^8","~$schema.spec.variant/map->VariantSpec","^F","src/cljc/schema/spec/variant.cljc","^J",23,"^R",["^M",[["^1S"]]],"^S",null,"^T",["^M",[null,null]],"^H",1,"^1D",true,"^U",false,"^1I","^1R","^G",41,"^V","^1B","^I",41,"^Y",1,"^Z",true,"^L",["^M",["^N",["^M",[["^1S"]]]]],"^1O","Factory function for schema.spec.variant/VariantSpec, taking a map of keywords to field values."],"~$variant-spec",["^ ","^D",null,"^E",["^ ","^F","/Users/ambrose/Projects/schema-local-dev/master/src/cljc/schema/spec/variant.cljc","^G",61,"^H",7,"^I",61,"^J",19,"^L",["^M",["^N",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]]]],"^1O","A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard).","~:top-fn",["^ ","^U",false,"~:fixed-arity",4,"^Y",4,"^R",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^L",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^T",["^M",[null,null,null]]]],"^8","~$schema.spec.variant/variant-spec","^F","src/cljc/schema/spec/variant.cljc","^J",19,"^1V",["^ ","^U",false,"^1W",4,"^Y",4,"^R",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^L",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^T",["^M",[null,null,null]]],"^R",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^S",null,"^1W",4,"^T",["^M",[null,null,null]],"^H",1,"^U",false,"~:methods",[["^ ","^1W",2,"^U",false,"^1F","^W"],["^ ","^1W",3,"^U",false,"^1F","^W"],["^ ","^1W",4,"^U",false,"^1F","^1B"]],"^G",61,"^I",61,"^Y",4,"^Z",true,"^L",["^M",[["^1K","^1L"],["^1K","^1L","^1M"],["^1K","^1L","^1M","^1N"]]],"^1O","A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard)."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$macros","~$schema.macros","^21","^21","^<","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["^1L","~:schema","~:return-walked?","~$throws?","~:pre","~:else","~:wrap-error","^1K","~:err-f","^1M","~:schema.spec.variant/exception","~:post","~:options","~:guard","^1N"]],"~:order",["^2>","^2;","^28","^24","^26","^29","^25","^27","^2=","^2:","^2<","^1K","^1L","^1M","^1N"]],"^1O",null]